
# Тесты 

В данном файле описаны тесты к программе. Для иллюстрации доски был использован **шахматный** редактор lichess: пешки - обычные шашки, короли - королевские пешки.
Белые = красные.
Счет считается сложением очков всех фигур на доске:

| Фигура           | Очки                      |  
| ---------------- | ------------------------- |
| Белая пешка      | 1                         |
| Черная пешка     | -1                        |
| Белый король     | 2                         |
| Черный король    | -2                        |

## Тест №0 (test0.cpp)
**Ход:** белые\
**Глубина дерева:** 4\
**Цель теста:** Демонстрация отсечения части ветвей дерева игры.
В данном тесте взяты алгоритмы из основной программы. Последнему уровню присвоены некоторые значения (В основной программе значения вычисляются непосредственно при запуске алгоритма, в пропущенных ветвях вычисление счета не производится) . Данный тест абстрагирован от основной программы по причине сложности нахождения хорошего примера для демонстрации работы алгоритма "альфа-бета-отсечение".

Альфа-бета-отсечение использует две рекурсивные функции `Max-value` и `Min-value`. Каждому узлу дерева алгоритм присваивает 2 значения, альфа и бета, которые представляют собой минимальное количество очков, которые готовится получить игрок *максимизации* (белые) и максимальное количество очков, которые готовится получить игрок *минимизации* (черные). Изначально, `alpha = -inf` и `beta = inf`.  Всякий раз, когда максимальное количество очков,  ожидают которые черные, становятся меньше минимального количества очков, которые  ожидают  белые `(beta <= alpha)`, белые могут не рассматривать детей этой ветви, так как было найдено, что для этой ветви значение оценивающей функции в любом случае хуже, чем вычисленное для предыдущей ветви.

Изначальное дерево (входные данные):

 ![](https://i.imgur.com/7hFZUkL.png)

Далее запускают две рекурсивные функции:
```
double _maxValue(TreeNode*& node, double alpha, double beta) {
		node->_alpha = alpha;
		node->_beta = beta;
		if (node->_children.size() == 0) {
			return node->_value;
		}
		node->_value = -std::numeric_limits<double>::infinity();
		for (unsigned int i = 0; i < node->_children.size(); ++i) {
			double tempValue = _minValue(
				node->_children.at(i), node->_alpha, node->_beta);
			if (tempValue > node->_value)
				node->_value = tempValue;
			if (tempValue >= node->_beta)
				return node->_value;
			if (tempValue > node->_alpha)
				node->_alpha = tempValue;
		}
		return node->_value;
	}
	double _minValue(TreeNode*& node, double alpha, double beta) {
		node->_alpha = alpha;
		node->_beta = beta;
		if (node->_children.size() == 0) {
			return node->_value;
		}
		node->_value = std::numeric_limits<double>::infinity();
		for (unsigned int i = 0; i < node->_children.size(); ++i) {
			double tempValue = _maxValue(
				node->_children.at(i), node->_alpha, node->_beta);
			if (tempValue < node->_value)
				node->_value = tempValue;
			if (tempValue <= node->_alpha)
				return node->_value;
			if (tempValue < node->_beta)
				node->_beta = tempValue;
		}
		return node->_value;
	}
```
В выходных данных получаем вес хода и количество вызовов функции:
```
Optimal Move Score: 8 
Number of calls: 11
```
Полученные выходные данные соответствуют дереву ходов (оптимальный ход - 8, функция вызывалась 11 раз из 15, по количеству пройденных узлов):

![](https://i.imgur.com/hcqydOR.png)

## Тест №1
**Ход:** белые\
**Глубина дерева:** 4\
**Цель теста:** демонстрация работы алгоритма

![](https://i.imgur.com/CwuPDOh.png)

У белых 3 возможных хода:

| Ход              | Счет (с учетом глубины дерева) |  
| ---------------- | ------------------------------ |
| 8-17             | -3                             |
| 40x58x37x23      | 1                              |
| 40x58x37x19x1    | 2                              |

Очевиден ход, который выбрал алгоритм (пешка встаёт на поле 58 и становится королём): 
```
40x58x37x19x1
```

## Тест №2
**Ход:** черные.\
**Глубина дерева:** 4 \
**Цель теста:** демонстрация предотвращения хорошего ход противника. Алгоритм не даёт белым сделать выгодных ход `40x58x37x19x1`.
**Аналогичная ситуация на доске.**

Первый слой состоит из 15 возможных ходов черных, два из которых имеют наивысший вес:

| Ход              | Счет (с учетом глубины дерева) |  
| ---------------- | ------------------------------ |
| 44-58            | -5                             |
| 49-42            | -5                             |

Ход, который выбрал алгоритм (король блокирует передвижение пешки):
```
44-58
```

## Тест №3

**Ход:** черные.\
**Глубина дерева:** 1.\
**Цель теста:** демонстрация неверного хода алгоритма при маленькой глубине построения дерева.\
**Аналогичная ситуация на доске**.

Первый слой состоит из 15 возможных ходов черных, все с весом `-5`.
Алгоритм выбирает первый возможный ход.
```
10-3
```

## Тест №4
**Ход:** N\A.\
**Глубина дерева:** N\A.\
**Цель теста:** демонстрация вывода сообщения об ошибки в случае неверных входных данных.

Входные данные:
```
00000000
00300000
00000000
00000000
00000000
00000000
00000000
00000000
hhohoihorx
```
Выходные данные (размер входных данных является неверным): 
```
Error1
```

## Тест  №5
**Ход:** белые.\
**Глубина дерева:** 3.\
**Цель теста:** демонстрация вывода сообщения победы противника, при невозможности хода игрока.

![](https://i.imgur.com/xHQEXyY.png)

Белой фигуре ход блокирован (черные победили):
```
black win
```
## Тест  №6
**Ход:** черные.\
**Глубина дерева:** 3.\
**Цель теста:** демонстрация работы алгоритма в случае равной первичной оценки.

![](https://i.imgur.com/UjJXAZl.png)

Черная фигура может пойти направо или налево. Фигура пойдет на право, чтобы быть ближе к боковой линии -- безопасной зоне.
```
29x15
```

## Тест  №7
**Ход:** белые.\
**Глубина дерева:** 3.\
**Цель теста:** демонстрация тихого хода дамки.

![](https://i.imgur.com/Z5YNZHt.png)

Для теста была добавлена переменная `notation`, которой присваивались нотации всех возможных ходов корня. `notation` выводится в файл для проверки алгоритма. 
```
for (unsigned int i = 0; i < root->getChildren().size(); ++i) {
	notation = notation + root->getChildren().at(i)->getNotation() + " ";
}
writeNotationToFile(notation , argv[2]);
```

Выходные данные:
```
10-1 10-3 10-19 10-28 10-37 10-46 10-55 10-17 10-24 
```
Именно столько различных ходов может сделать дамка.

## Тест  №8
**Ход:** белые.\
**Глубина дерева:** 3.\
**Цель теста:** демонстрация боя дамки.

![](https://i.imgur.com/V0IB71R.png)

Для теста также использована переменная `notation`. В шашках бой неизбежен (нельзя провести тихий ход, при возможности боя). Дамка может производить бой по диагонали через несколько клеток. В данном случае возможно 2 хода. 

Выходные данные:
```
10x37x55 10x24  
```

## Тест  №9
**Ход:** черные.\
**Глубина дерева:** 3.\
**Цель теста:** демонстрация боя шашки с превращением в дамку.

![](https://i.imgur.com/EnMnpKj.png)

В тесте черная шашка может, съев белую шашку на поел 10 превратиться в дамку и съесть белую дамку на 46. Для теста также использована переменная `notation`.  В данном случае возможно 4 хода. 
Выходные данные:
```
19x1x37x55 19x5x33 19x33 19x37x55
```